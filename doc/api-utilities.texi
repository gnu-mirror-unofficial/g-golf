@c -*-texinfo-*-
@c This is part of the GNU G-Golf Reference Manual.
@c Copyright (C) 2016 - 2018 Free Software Foundation, Inc.
@c See the file g-golf.texi for copying conditions.


@c @defindex tl


@node Utilities
@subsection Utilities

G-Golf GObject Introspetion Utilities low level API.@*


@subheading Procedures and Syntax

@indentedblock
@table @code
@item @ref{gi-pointer-new}
@item @ref{gi-pointer-inc}
@item @ref{gi-attribute-iter-new}
@item @ref{with-gerror}
@item @ref{gi->scm}
@item @ref{gi-boolean->scm}
@item @ref{gi-string->scm}
@item @ref{gi-strings->scm}
@item @ref{gi-csv-string->scm}
@item @ref{gi-pointer->scm}
@item @ref{gstudly-caps-expand}
@item @ref{gi-name->scm-name}
@item @ref{gi-name->class-name}
@item @ref{gi-integer->gflags}
@item @ref{gi-gflags->integer}
@end table
@end indentedblock


@subheading Types and Values

@indentedblock
@table @code
@item @ref{%gi-pointer-size}
@item @ref{%gi-name-transform-exceptions}
@end table
@end indentedblock


@c @subheading Struct Hierarchy

@c @indentedblock
@c GIBaseInfo           	       		@*
@c @ @ +--- GIRegisteredTypeInfo  		@*
@c @ @ @ @ @ @ @ @ @ @ @  +--- GIEnumInfo
@c @end indentedblock


@subheading Description

G-Golf GObject Introspection utilities low level API.@*


@subheading Procedures and Syntax


@anchor{gi-pointer-new}
@deffn Procedure gi-pointer-new

Returns a newly allocated (Glib) pointer.
@end deffn


@anchor{gi-pointer-inc}
@deffn Procedure gi-pointer-inc pointer [#:offset %gi-pointer-size]

Returns a foreign pointer object pointing to the address of
@var{pointer} increased by @var{offset}.
@end deffn


@anchor{gi-attribute-iter-new}
@deffn Procedure gi-attribute-iter-new

Returns a pointer.

Creates and returns a foreign pointer to a C struct for a
@code{GIAttributeIter} (a C struct containg four pointers, initialized
to @code{%null-pointer}).
@end deffn


@anchor{with-gerror}
@deffn Procedure with-gerror var body

Returns the result of the execution of @var{body}, or raises an
exception.

@var{var} must be an identifier.  Evaluate @var{body} in a lexical
environment where @var{var} is bound to a pointer to a newly allocated
(and @samp{empty}) @code{GError}. @var{var} will always be freed.  If no
exception is raised, the result of the execution of @var{body} is
returned.

@c Here is an example, taken from the definition of
@c @ref{g-irepository-require}, in the @code{(g-golf gi repository)}
@c module:

@c @lisp
@c (define* (g-irepository-require namespace
@c                                 #:key (version #f)
@c                                 (repository %null-pointer))
@c   (with-gerror g-error
@c 	       (g_irepository_require repository
@c 				      (string->pointer namespace)
@c 				      (if version
@c 					  (string->pointer version)
@c 					  %null-pointer)
@c 				      0
@c 				      g-error)))
@c @end lisp
@end deffn


@anchor{gi->scm}
@deffn Procedure gi->scm value type

Returns the scheme representation of @var{value}.

The accepted @var{type} symbols (also called @code{tags} in the
@code{GI} terminology@footnote{All (G-Golf) procedures that accept a GI
tag as an argument will accept the tag as an integer (the GI
representation) or a symbol (the scheme representation).  All (G-Golf)
procedures that return a tag will always return the scheme
representation.}) are:

@indentedblock
@table @code
@item boolean
The GType of @var{value} is @code{gboolean}.  The returned value is
@code{#t} or @code{#f}.

@item string
The GType of @var{value} is @code{*gchar}.  The returned value is a
string or @code{#f} (when @var{value} is the @code{%null-pointer}).

@item strings
The GType of @var{value} is @code{**gchar} (an array of pointers to
@code{*gchar}), returned as a list of strings, which can be empty (when
@var{value} is the @code{%null-pointer}).

@item csv-string
The GType of @var{value} is @code{g*char}. The returned value is a list
of strings, obtained by splitting @var{value} using @code{#\,} as the
@code{char-pred}, or @code{#f} (when @var{value} is the
@code{%null-pointer}).

@item pointer
The GType of @var{value} is @code{gpointer}. The returned value is a
pointer or @code{#f} (when @var{value} is the @code{%null-pointer}).

@end table
@end indentedblock
@end deffn


@anchor{gi-boolean->scm}
@deffn Procedure gi-boolean->scm value

Returns @code{#t} or @code{#f}.

The GType of @var{value} is @code{gboolean}.
@end deffn


@anchor{gi-string->scm}
@deffn Procedure gi-string->scm value

Returns a string or @code{#f}.

The GType of @var{value} is @code{gchar*}. When @var{value} is the
@code{%null-pointer}, the procedure returns @code{#f}.
@end deffn


@anchor{gi-strings->scm}
@deffn Procedure gi-strings->scm value

Returns a list of strings (which can be empty).

The GType of @var{value} is @code{gchar**} (an array of pointers to
@code{*gchar}).
@end deffn


@anchor{gi-csv-string->scm}
@deffn Procedure gi-csv-string->scm value

Returns a list of strings or @code{#f}.

The GType of @var{value} is @code{gchar*}.  When the returned value is a
list of strings, it is obtained by splitting @var{value} using
@code{#\,} as the @code{char-pred}.  When @var{value} is the
@code{%null-pointer}, the procedure returns @code{#f}.
@end deffn


@anchor{gi-pointer->scm}
@deffn Procedure gi-pointer->scm value

Returns a pointer or @code{#f}.

The GType of @var{value} is @code{gpointer}.  When @var{value} is the
@code{%null-pointer}, the procedure returns @code{#f}.
@end deffn


@anchor{gstudly-caps-expand}
@deffn Procedure gstudly-caps-expand str

Returns a string.

Given a @samp{@uref{@value{UWIKI-CAMELCASE}, Camel Case}} string, this
procedure@footnote{This procedure, as well as @ref{gi-name->scm-name}
and @ref{gi-name->class-name} come from @uref{@value{UGG}, Guile-Gnome},
where there are named @code{GStudlyCapsExpand},
@code{gtype-name->scm-name} and @code{gtype-name->class-name}, in the
(Guile-Gnome) module (gnome gobject utils).  In G-Golf, these will also
be used to transform other (Gobject Inptrospection given) names, such as
function names, hence their @code{gi-name->} prefix instead} returns a
new string, with all uppercase letters being transformed into their
corresponding lowercase letter, and where a @code{#\-} is inserted in
between occurrences of two consecutive uppercase letters.  Here is an
example:

@lisp
(gstudly-caps-expand "GStudlyCapsExpand")
@print{}
$2 = "g-studly-caps-expand"
@end lisp
@end deffn


@anchor{gi-name->scm-name}
@anchor{gi-name->class-name}
@deffn Procedure gi-name->scm-name type-name
@deffnx Procedure gi-name->class-name type-name

Returns a string - a symbol - respectively.

The former obtains the scheme name for @var{type-name}, by transforming
@code{#\_} into @code{#\-} and calling @ref{gstudly-caps-expand}. The
later uses the former, surrounds the result using @code{#\<} and
@code{#\>} characters then calls @code{string->symbol}. For example:

@lisp
(gi-name->class-name "ClutterActor")
@print{}
$2 = <clutter-actor>
@end lisp
@end deffn


@anchor{gi-integer->gflags}
@anchor{gi-gflags->integer}
@deffn Procedure gi-integer->gflags gflags n
@deffnx Procedure gi-gflags->integer gflags flags

Returns a list of flags (symbols) - an integer - respectively.

The former obtains the list of flags, from @var{gflags}, corresponding
to the given integer @var{n}.  The latter returns an integer,
corresponding to the given list of @var{flags}, comparing those against
@var{gflags}.  In both cases, @var{gflags} is (must be) a
@code{<gi-enum>} instance, for example @ref{%g-param-flags}.
@end deffn


@subheading Types and Values


@anchor{%gi-pointer-size}
@defvar %gi-pointer-size

The size that a (Glib) pointer occupies in memory (currently 8 bytes).
@end defvar


@anchor{%gi-name-transform-exceptions}
@defvar %gi-name-transform-exceptions

Contains an alist where each @code{key} is a GType name exception for
the @ref{gi-name->scm-name} procedure, and the corresponding
@code{value} the string that @ref{gi-name->scm-name} will return
instead. As an example, it could be defined as:

@lisp
(define %gi-name-transform-exceptions
        '((GEnum . genum)))
@end lisp

However currently it is an exmpty list@footnote{@uref{@value{UGG},
Guile-Gnome} defines a relatively long list of those GType name
exceptions, including GEnum, but I'm still not sure about what G-Golf
will do and currently decided not to apply any exception.  Will this
change in the future? Maybe, but it will become stable before G-Golf
1.0.}.
@end defvar
